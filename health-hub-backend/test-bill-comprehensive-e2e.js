/**
 * Comprehensive E2E Test Suite: Diagnostic Bill Generation with Price Snapshot
 * 
 * This test suite validates all acceptance criteria via API endpoints (simulating browser behavior)
 * 
 * Acceptance Criteria:
 * 1. Bill auto-generated on visit creation
 * 2. Prices snapshotted (future price changes do not affect visit)
 * 3. Bill number is branch-scoped and unique
 * 4. Bill immutable after generation
 * 
 * Run: node test-bill-comprehensive-e2e.js
 */

const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

const BASE_URL = 'http://localhost:3000';
let AUTH_TOKEN = null;
let TEST_BRANCH = null;

const TEST_RESULTS = [];

async function log(testName, status, details = '') {
  const symbol = status === 'PASS' ? 'âœ…' : status === 'FAIL' ? 'âŒ' : 'âš ï¸';
  const line = `${symbol} ${testName}${details ? `: ${details}` : ''}`;
  console.log(line);
  TEST_RESULTS.push({ testName, status, details });
}

async function makeRequest(method, path, body = null, headers = {}) {
  const fetch = (await import('node-fetch')).default;
  const options = {
    method,
    headers: {
      'Content-Type': 'application/json',
      ...(AUTH_TOKEN && { 'Authorization': `Bearer ${AUTH_TOKEN}` }),
      ...(TEST_BRANCH && { 'X-Branch-Id': TEST_BRANCH.id }),
      ...headers,
    },
  };
  if (body) options.body = JSON.stringify(body);
  
  try {
    const response = await fetch(`${BASE_URL}${path}`, options);
    const data = await response.json().catch(() => null);
    return { status: response.status, data, ok: response.ok };
  } catch (error) {
    return { status: 0, data: null, ok: false, error: error.message };
  }
}

async function setup() {
  console.log('\n' + '='.repeat(70));
  console.log('SETUP: Authenticating and preparing test data');
  console.log('='.repeat(70));

  // Login to get token
  const loginRes = await makeRequest('POST', '/api/auth/login', {
    email: 'staff@sobhana.com',
    password: 'password123',
  });

  if (!loginRes.ok) {
    throw new Error(`Login failed: ${JSON.stringify(loginRes.data)}`);
  }

  AUTH_TOKEN = loginRes.data.token;
  console.log('âœ… Logged in successfully');

  // Get branch
  TEST_BRANCH = await prisma.branch.findFirst({ where: { isActive: true } });
  if (!TEST_BRANCH) throw new Error('No active branch found');
  console.log(`âœ… Using branch: ${TEST_BRANCH.name} (${TEST_BRANCH.code})`);

  return true;
}

async function test1_BillAutoGeneratedOnVisitCreation() {
  console.log('\n' + '='.repeat(70));
  console.log('TEST 1: Bill Auto-Generated on Visit Creation');
  console.log('='.repeat(70));

  // Get test data
  const patient = await prisma.patient.findFirst();
  const tests = await prisma.labTest.findMany({ where: { isActive: true }, take: 2 });

  if (!patient || tests.length < 2) {
    await log('Setup test data', 'FAIL', 'No patient or tests found');
    return null;
  }

  // Create visit via API
  const createRes = await makeRequest('POST', '/api/visits/diagnostic', {
    patientId: patient.id,
    testIds: tests.map(t => t.id),
    paymentType: 'CASH',
    paymentStatus: 'PENDING',
  });

  if (!createRes.ok) {
    await log('Create diagnostic visit via API', 'FAIL', 
      `Status: ${createRes.status}, Error: ${JSON.stringify(createRes.data)}`);
    return null;
  }

  await log('Create diagnostic visit via API', 'PASS', 
    `Visit ID: ${createRes.data.id}`);

  // Verify visit has bill number
  if (createRes.data.billNumber) {
    await log('Visit has bill number', 'PASS', 
      `Bill Number: ${createRes.data.billNumber}`);
  } else {
    await log('Visit has bill number', 'FAIL', 'No bill number returned');
    return null;
  }

  // Verify bill record exists in database
  const bill = await prisma.bill.findFirst({
    where: { visitId: createRes.data.id },
  });

  if (bill) {
    await log('Bill record created in database', 'PASS', 
      `Bill ID: ${bill.id}`);
  } else {
    await log('Bill record created in database', 'FAIL');
    return null;
  }

  // Verify bill matches visit
  if (bill.billNumber === createRes.data.billNumber) {
    await log('Bill number matches visit', 'PASS');
  } else {
    await log('Bill number matches visit', 'FAIL');
  }

  // Verify total amount
  const expectedTotal = tests.reduce((sum, t) => sum + t.priceInPaise, 0);
  if (bill.totalAmountInPaise === expectedTotal) {
    await log('Bill total correct', 'PASS', 
      `â‚¹${bill.totalAmountInPaise / 100}`);
  } else {
    await log('Bill total correct', 'FAIL', 
      `Expected: ${expectedTotal}, Got: ${bill.totalAmountInPaise}`);
  }

  return { visitId: createRes.data.id, billNumber: createRes.data.billNumber, tests };
}

async function test2_PriceSnapshotImmutability(testData) {
  console.log('\n' + '='.repeat(70));
  console.log('TEST 2: Prices Snapshotted (Future Changes Don\'t Affect Visit)');
  console.log('='.repeat(70));

  if (!testData) {
    await log('Price snapshot test', 'SKIP', 'No test data from previous test');
    return;
  }

  // Get test orders
  const testOrders = await prisma.testOrder.findMany({
    where: { visitId: testData.visitId },
    include: { test: true },
  });

  if (testOrders.length === 0) {
    await log('Test orders exist', 'FAIL');
    return;
  }

  await log('Test orders exist', 'PASS', `${testOrders.length} orders found`);

  // Verify snapshot fields populated
  const order = testOrders[0];
  const snapshotCheck = {
    name: order.testNameSnapshot === order.test.name,
    code: order.testCodeSnapshot === order.test.code,
    price: order.priceInPaise === order.test.priceInPaise,
  };

  if (snapshotCheck.name && snapshotCheck.code && snapshotCheck.price) {
    await log('Snapshot data captured at order time', 'PASS',
      `Name: ${order.testNameSnapshot}, Code: ${order.testCodeSnapshot}, Price: â‚¹${order.priceInPaise/100}`);
  } else {
    await log('Snapshot data captured at order time', 'FAIL');
  }

  // Now change the price in master catalog
  const testId = testOrders[0].testId;
  const originalPrice = testOrders[0].test.priceInPaise;
  const newPrice = originalPrice * 3; // Triple the price

  await prisma.labTest.update({
    where: { id: testId },
    data: { priceInPaise: newPrice },
  });

  console.log(`  ðŸ“ Changed master catalog price from â‚¹${originalPrice/100} to â‚¹${newPrice/100}`);

  // Fetch visit via API to check what frontend would see
  const visitRes = await makeRequest('GET', `/api/visits/diagnostic/${testData.visitId}`);

  if (visitRes.ok) {
    const orderInResponse = visitRes.data.testOrders.find(o => o.testId === testId);
    
    // The price in the response should be the SNAPSHOTTED price, not the new catalog price
    if (orderInResponse && orderInResponse.price === originalPrice / 100) {
      await log('Visit shows snapshotted price (not catalog price)', 'PASS',
        `Display price: â‚¹${orderInResponse.price}, New catalog: â‚¹${newPrice/100}`);
    } else {
      await log('Visit shows snapshotted price (not catalog price)', 'FAIL',
        `Expected: â‚¹${originalPrice/100}, Got: â‚¹${orderInResponse?.price}`);
    }
  } else {
    await log('Fetch visit for price verification', 'FAIL');
  }

  // Get bill data via API (what print page would see)
  const billRes = await makeRequest('GET', `/api/bills/DIAGNOSTICS/${testData.visitId}`);

  if (billRes.ok) {
    const itemInBill = billRes.data.items.find(i => i.id === testOrders[0].id);
    
    // Bill should show original snapshotted price
    if (itemInBill && itemInBill.price === originalPrice / 100) {
      await log('Bill print shows snapshotted price', 'PASS',
        `Bill item price: â‚¹${itemInBill.price}`);
    } else {
      await log('Bill print shows snapshotted price', 'FAIL',
        `Expected: â‚¹${originalPrice/100}, Got: â‚¹${itemInBill?.price}`);
    }
  } else {
    await log('Fetch bill data', 'FAIL');
  }

  // Revert price change
  await prisma.labTest.update({
    where: { id: testId },
    data: { priceInPaise: originalPrice },
  });
  console.log(`  ðŸ“ Reverted catalog price to â‚¹${originalPrice/100}`);
}

async function test3_BillNumberBranchScopedUnique() {
  console.log('\n' + '='.repeat(70));
  console.log('TEST 3: Bill Number is Branch-Scoped and Unique');
  console.log('='.repeat(70));

  // Verify bill number format: D-{BRANCH_CODE}-{SEQ}
  const bills = await prisma.bill.findMany({
    where: { branchId: TEST_BRANCH.id },
    orderBy: { createdAt: 'desc' },
    take: 5,
  });

  if (bills.length === 0) {
    await log('Bills exist', 'FAIL', 'No bills found');
    return;
  }

  const formatRegex = new RegExp(`^D-${TEST_BRANCH.code}-\\d{5}$`);
  const validFormat = bills.every(b => formatRegex.test(b.billNumber));

  if (validFormat) {
    await log('Bill number format correct', 'PASS',
      `Format: D-${TEST_BRANCH.code}-XXXXX, Example: ${bills[0].billNumber}`);
  } else {
    await log('Bill number format correct', 'FAIL',
      `Expected: D-${TEST_BRANCH.code}-XXXXX, Found: ${bills.find(b => !formatRegex.test(b.billNumber))?.billNumber}`);
  }

  // Check uniqueness within branch
  const duplicates = await prisma.$queryRaw`
    SELECT "billNumber", COUNT(*) as count
    FROM "Bill"
    WHERE "branchId" = ${TEST_BRANCH.id}
    GROUP BY "billNumber"
    HAVING COUNT(*) > 1
  `;

  if (duplicates.length === 0) {
    await log('No duplicate bill numbers in branch', 'PASS');
  } else {
    await log('No duplicate bill numbers in branch', 'FAIL',
      `Found ${duplicates.length} duplicates`);
  }

  // Verify sequence increments correctly
  if (bills.length >= 2) {
    const numbers = bills.map(b => parseInt(b.billNumber.split('-').pop())).sort((a, b) => b - a);
    const isSequential = numbers.every((num, idx) => idx === 0 || numbers[idx - 1] >= num);
    
    if (isSequential) {
      await log('Bill numbers are sequential', 'PASS',
        `Recent: ${numbers.slice(0, 3).join(', ')}`);
    } else {
      await log('Bill numbers are sequential', 'FAIL');
    }
  }

  // Test unique constraint at database level
  const visit = await prisma.visit.findFirst({ where: { branchId: TEST_BRANCH.id } });
  if (visit) {
    try {
      // Try to create a duplicate bill number (should fail)
      await prisma.bill.create({
        data: {
          visitId: visit.id,
          billNumber: bills[0].billNumber, // Duplicate!
          branchId: TEST_BRANCH.id,
          totalAmountInPaise: 0,
        },
      });
      await log('Unique constraint enforced', 'FAIL', 'Duplicate was allowed');
    } catch (error) {
      if (error.code === 'P2002') {
        await log('Unique constraint enforced at DB level', 'PASS',
          'Duplicate bill number rejected');
      } else {
        await log('Unique constraint enforced', 'PASS', 
          `Error: ${error.message.substring(0, 50)}`);
      }
    }
  }
}

async function test4_BillImmutability(testData) {
  console.log('\n' + '='.repeat(70));
  console.log('TEST 4: Bill Immutable After Generation');
  console.log('='.repeat(70));

  // Check trigger exists
  const triggers = await prisma.$queryRaw`
    SELECT trigger_name, event_manipulation 
    FROM information_schema.triggers 
    WHERE event_object_table = 'Bill' AND event_manipulation = 'UPDATE'
  `;

  if (triggers.length > 0) {
    await log('Immutability trigger exists', 'PASS',
      `Trigger: ${triggers[0].trigger_name}`);
  } else {
    await log('Immutability trigger exists', 'FAIL');
  }

  if (!testData) {
    await log('Bill immutability tests', 'SKIP', 'No test data');
    return;
  }

  const bill = await prisma.bill.findFirst({ where: { visitId: testData.visitId } });
  if (!bill) {
    await log('Get bill for testing', 'FAIL');
    return;
  }

  // Test 4a: Payment status change SHOULD be allowed
  try {
    await prisma.bill.update({
      where: { id: bill.id },
      data: { paymentStatus: 'PAID' },
    });
    await log('Payment status update allowed', 'PASS',
      'Can update payment status (expected)');
    
    // Revert
    await prisma.bill.update({
      where: { id: bill.id },
      data: { paymentStatus: 'PENDING' },
    });
  } catch (error) {
    await log('Payment status update allowed', 'FAIL',
      `Should be allowed: ${error.message.substring(0, 50)}`);
  }

  // Test 4b: Bill number change SHOULD be blocked
  try {
    await prisma.bill.update({
      where: { id: bill.id },
      data: { billNumber: 'HACKER-ATTACK-001' },
    });
    await log('Bill number change blocked', 'FAIL',
      'Bill number update succeeded when it should have been blocked!');
  } catch (error) {
    if (error.message.includes('Cannot modify bill number') || error.message.includes('immutable')) {
      await log('Bill number change blocked', 'PASS',
        'Trigger prevented modification');
    } else {
      await log('Bill number change blocked', 'PASS',
        `Blocked (constraint): ${error.message.substring(0, 40)}`);
    }
  }

  // Test 4c: Branch change SHOULD be blocked
  try {
    const otherBranch = await prisma.branch.findFirst({ 
      where: { id: { not: TEST_BRANCH.id } } 
    });
    if (otherBranch) {
      await prisma.bill.update({
        where: { id: bill.id },
        data: { branchId: otherBranch.id },
      });
      await log('Branch change blocked', 'FAIL',
        'Branch update succeeded when it should have been blocked!');
    }
  } catch (error) {
    if (error.message.includes('Cannot modify bill branch') || error.message.includes('immutable')) {
      await log('Branch change blocked', 'PASS',
        'Trigger prevented modification');
    } else {
      await log('Branch change blocked', 'PASS',
        `Blocked: ${error.message.substring(0, 40)}`);
    }
  }

  // Test 4d: Visit association change SHOULD be blocked
  try {
    const otherVisit = await prisma.visit.findFirst({
      where: { id: { not: testData.visitId } },
    });
    if (otherVisit) {
      await prisma.bill.update({
        where: { id: bill.id },
        data: { visitId: otherVisit.id },
      });
      await log('Visit association change blocked', 'FAIL',
        'Visit ID update succeeded when it should have been blocked!');
    }
  } catch (error) {
    if (error.message.includes('Cannot modify bill visit') || error.message.includes('immutable')) {
      await log('Visit association change blocked', 'PASS',
        'Trigger prevented modification');
    } else {
      await log('Visit association change blocked', 'PASS',
        `Blocked: ${error.message.substring(0, 40)}`);
    }
  }

  // Test 4e: Direct SQL update attempt (bypassing Prisma)
  try {
    await prisma.$executeRaw`
      UPDATE "Bill" SET "billNumber" = 'SQL-INJECTION-001' WHERE id = ${bill.id}
    `;
    await log('SQL injection attempt blocked', 'FAIL',
      'Direct SQL update succeeded!');
  } catch (error) {
    await log('SQL injection attempt blocked', 'PASS',
      'Trigger blocks even raw SQL');
  }
}

async function test5_ConcurrentVisitCreation() {
  console.log('\n' + '='.repeat(70));
  console.log('TEST 5: Concurrent Visit Creation (Race Condition Test)');
  console.log('='.repeat(70));

  const patient = await prisma.patient.findFirst();
  const tests = await prisma.labTest.findMany({ where: { isActive: true }, take: 1 });

  if (!patient || tests.length === 0) {
    await log('Concurrent test setup', 'FAIL');
    return;
  }

  // Create multiple visits concurrently
  const CONCURRENT_COUNT = 5;
  const promises = [];

  for (let i = 0; i < CONCURRENT_COUNT; i++) {
    promises.push(
      makeRequest('POST', '/api/visits/diagnostic', {
        patientId: patient.id,
        testIds: tests.map(t => t.id),
        paymentType: 'CASH',
        paymentStatus: 'PENDING',
      })
    );
  }

  console.log(`  ðŸ“ Creating ${CONCURRENT_COUNT} visits concurrently...`);
  const results = await Promise.all(promises);

  const successes = results.filter(r => r.ok);
  const failures = results.filter(r => !r.ok);

  if (successes.length === CONCURRENT_COUNT) {
    await log('All concurrent visits created', 'PASS',
      `${CONCURRENT_COUNT}/${CONCURRENT_COUNT} succeeded`);
  } else {
    await log('All concurrent visits created', 'FAIL',
      `${successes.length}/${CONCURRENT_COUNT} succeeded, ${failures.length} failed`);
    failures.forEach(f => console.log(`    Error: ${JSON.stringify(f.data)}`));
  }

  // Check all bill numbers are unique
  const billNumbers = successes.map(r => r.data.billNumber);
  const uniqueBillNumbers = new Set(billNumbers);

  if (uniqueBillNumbers.size === successes.length) {
    await log('All bill numbers unique', 'PASS',
      `${uniqueBillNumbers.size} unique numbers`);
  } else {
    await log('All bill numbers unique', 'FAIL',
      `${uniqueBillNumbers.size} unique out of ${successes.length}`);
    console.log(`    Bill numbers: ${billNumbers.join(', ')}`);
  }

  // Check sequential ordering
  const numbers = billNumbers.map(bn => parseInt(bn.split('-').pop())).sort((a, b) => a - b);
  const isSequential = numbers.every((num, idx) => idx === 0 || num === numbers[idx - 1] + 1);

  if (isSequential) {
    await log('Bill numbers are sequential', 'PASS',
      `Sequence: ${numbers.join(', ')}`);
  } else {
    await log('Bill numbers are sequential', 'INFO',
      `Numbers: ${numbers.join(', ')} (gaps may exist from retries)`);
  }

  // Cleanup: Delete test visits
  for (const result of successes) {
    await prisma.diagnosticReport.deleteMany({ where: { visitId: result.data.id } });
    await prisma.testOrder.deleteMany({ where: { visitId: result.data.id } });
    await prisma.bill.deleteMany({ where: { visitId: result.data.id } });
    await prisma.visit.delete({ where: { id: result.data.id } });
  }
}

async function test6_BillPrintDataIntegrity() {
  console.log('\n' + '='.repeat(70));
  console.log('TEST 6: Bill Print Data Integrity');
  console.log('='.repeat(70));

  // Create a visit with known data
  const patient = await prisma.patient.findFirst();
  const tests = await prisma.labTest.findMany({ where: { isActive: true }, take: 2 });
  const referralDoc = await prisma.referralDoctor.findFirst({ where: { isActive: true } });

  const createRes = await makeRequest('POST', '/api/visits/diagnostic', {
    patientId: patient.id,
    testIds: tests.map(t => t.id),
    referralDoctorId: referralDoc?.id,
    paymentType: 'CASH',
    paymentStatus: 'PENDING',
  });

  if (!createRes.ok) {
    await log('Create visit for print test', 'FAIL');
    return;
  }

  const visitId = createRes.data.id;

  // Get bill print data via API
  const billRes = await makeRequest('GET', `/api/bills/DIAGNOSTICS/${visitId}`);

  if (!billRes.ok) {
    await log('Get bill print data', 'FAIL');
    return;
  }

  await log('Get bill print data', 'PASS');

  const billData = billRes.data;

  // Verify all required print fields exist
  const requiredFields = {
    'visit.billNumber': billData.visit?.billNumber,
    'visit.totalAmount': billData.visit?.totalAmount,
    'patient.name': billData.patient?.name,
    'branch.name': billData.branch?.name,
    'payment.type': billData.payment?.type,
    'items': billData.items?.length > 0,
  };

  const missingFields = Object.entries(requiredFields)
    .filter(([_, value]) => !value)
    .map(([key]) => key);

  if (missingFields.length === 0) {
    await log('All print fields present', 'PASS');
  } else {
    await log('All print fields present', 'FAIL',
      `Missing: ${missingFields.join(', ')}`);
  }

  // Verify prices match
  const expectedTotal = tests.reduce((sum, t) => sum + t.priceInPaise, 0) / 100;
  if (billData.visit.totalAmount === expectedTotal) {
    await log('Print total matches visit total', 'PASS',
      `â‚¹${billData.visit.totalAmount}`);
  } else {
    await log('Print total matches visit total', 'FAIL',
      `Expected: â‚¹${expectedTotal}, Got: â‚¹${billData.visit.totalAmount}`);
  }

  // Cleanup
  await prisma.diagnosticReport.deleteMany({ where: { visitId } });
  await prisma.testOrder.deleteMany({ where: { visitId } });
  await prisma.bill.deleteMany({ where: { visitId } });
  await prisma.visit.delete({ where: { id: visitId } });
}

async function cleanup(testData) {
  console.log('\n' + '='.repeat(70));
  console.log('CLEANUP');
  console.log('='.repeat(70));

  if (testData?.visitId) {
    try {
      await prisma.diagnosticReport.deleteMany({ where: { visitId: testData.visitId } });
      await prisma.reportVersion.deleteMany({ 
        where: { report: { visitId: testData.visitId } } 
      });
      await prisma.testOrder.deleteMany({ where: { visitId: testData.visitId } });
      await prisma.referralDoctor_Visit.deleteMany({ where: { visitId: testData.visitId } });
      await prisma.bill.deleteMany({ where: { visitId: testData.visitId } });
      await prisma.visit.delete({ where: { id: testData.visitId } });
      console.log('âœ… Test data cleaned up');
    } catch (error) {
      console.log(`âš ï¸ Cleanup warning: ${error.message}`);
    }
  }
}

async function printSummary() {
  console.log('\n' + '='.repeat(70));
  console.log('TEST SUMMARY');
  console.log('='.repeat(70));

  const passed = TEST_RESULTS.filter(r => r.status === 'PASS').length;
  const failed = TEST_RESULTS.filter(r => r.status === 'FAIL').length;
  const skipped = TEST_RESULTS.filter(r => r.status === 'SKIP' || r.status === 'INFO').length;

  console.log(`\nTotal Tests: ${TEST_RESULTS.length}`);
  console.log(`âœ… Passed: ${passed}`);
  console.log(`âŒ Failed: ${failed}`);
  console.log(`âš ï¸ Skipped/Info: ${skipped}`);

  if (failed > 0) {
    console.log('\nâŒ FAILED TESTS:');
    TEST_RESULTS.filter(r => r.status === 'FAIL').forEach(r => {
      console.log(`   - ${r.testName}: ${r.details}`);
    });
  }

  console.log('\n' + '='.repeat(70));
  console.log(failed === 0 ? 'ðŸŽ‰ ALL TESTS PASSED!' : 'âš ï¸ SOME TESTS FAILED');
  console.log('='.repeat(70));

  return failed;
}

async function runTests() {
  console.log('\n' + '='.repeat(70));
  console.log('COMPREHENSIVE E2E TEST: Diagnostic Bill with Price Snapshot');
  console.log('Testing via API endpoints (simulating browser behavior)');
  console.log('='.repeat(70));

  try {
    await setup();

    // Run all tests
    const testData = await test1_BillAutoGeneratedOnVisitCreation();
    await test2_PriceSnapshotImmutability(testData);
    await test3_BillNumberBranchScopedUnique();
    await test4_BillImmutability(testData);
    await test5_ConcurrentVisitCreation();
    await test6_BillPrintDataIntegrity();

    // Cleanup
    await cleanup(testData);

  } catch (error) {
    console.error('\nâŒ Test suite error:', error);
  }

  const failedCount = await printSummary();
  await prisma.$disconnect();
  process.exit(failedCount > 0 ? 1 : 0);
}

runTests();
